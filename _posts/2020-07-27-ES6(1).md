---
layout:     post
title:      第一部分：基础
subtitle:   ES6
date:       2020-07-27 15:00:00
author:     lixiaoguai
header-img: img/post-bg-webpack.jpg
catalog: 	 true
tags:
    - ES6
    - javascript
---

## let & const

1. ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
2. 不存在变量提升
3. 暂时性死区,在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。
4. 不允许重复声明
5. 块级作用域，使得匿名立即执行函数不再必要
6. const声明一个只读的常量。一旦声明，常量的值就不能改变。
7. const实际上保证的，并不是变量的值不得改动，而是变量指向的那个**内存地址所保存的数据**不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是**对象**和**数组**），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的
8. ES6 声明变量的六种方法：var,funcion, let, const, class, import
9. ES5 之中，顶层对象的属性与全局变量是等价的,被认为是 JavaScript 语言最大的设计败笔之一。问题：（1）没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）（2）很容易不知不觉地就创建了全局变量（3）顶层对象的属性是到处可以读写的，这非常不利于模块化编程
10. ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。

## 变量的解构赋值

1. 解构赋值：按照一定模式，从数组和对象中提取值，对变量进行赋值
2. 如果解构不成功，变量的值就等于undefined。
3. 不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。
4. 如果等号的右边不是可遍历的结构，那么将会报错。
5. 对象的解构赋值：对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
6. 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
7. 函数参数的解构赋值：参数是一个对象，通过对这个对象进行解构，得到多个变量值。
8. 用途：（1）交换变量的值（2）从函数返回多个值（3）函数参数的定义（4）提取 JSON 数据（5）函数参数的默认值（6）遍历 Map 结构（7）加载模块的指定方法

## 扩展

1. ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点
2. ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。
3. 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串之中还能调用函数。
4. Number.isFinite(), Number.isNaN()
5. ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。
6. Math.trunc()
Math.trunc方法用于去除一个数的小数部分，返回整数部分。

## 函数的扩展

