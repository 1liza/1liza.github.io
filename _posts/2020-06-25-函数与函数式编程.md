# 函数与函数式编程

## 一、函数声明、函数表达式、匿名函数与自执行函数

### 函数声明

JavaScript中，有两种声明方式，一个是使用var的变量声明，另一个是使用function的函数声明。

变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，**无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数**。

```js
fn();  // function

function fn() {
    console.log('function');
}
```

### 函数表达式

函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了**两步操作**。

```js
// 变量声明
var a = 20;

// 实际执行顺序
var a = undefined;  // 变量声明，初始值undefined，变量提升，提升顺序次于function声明
a = 20;  // 变量赋值，该操作不会提升
```

当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。

```js
fn(); // 报错
var fn = function() {
    console.log('function');
}
```

```js
在构造函数中添加方法
function Person(name) {
    this.name = name;
    this.age = age;
    // 在构造函数内部中添加方法
    this.getAge = function() {
        return this.age;
    }
    this.
}
// 给原型添加方法
Person.prototype.getName = function() {
    return this.name;
}

// 在对象中添加方法
var a = {
    m: 20,
    getM: function() {
        return this.m;
    }
}
```

### 匿名函数

匿名函数，就是指的没有被显示进行赋值操作的函数。它的使用场景，多**作为一个参数传入另一个函数中**。

由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为**回调函数**。

```js
var a = 10;
var fn = function(bar, num) {
    return bar() + num;
}

fn(function() {
    return a;
}, 20)
```

### 函数自执行与块级作用域

在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而**函数自执行，其实是匿名函数的一种应用**。

立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式(命名的或者匿名的)，在创建后立即执行；

这种模式有一些几部分组成：

- 使用函数表达式定义一个函数(函数声明不能起作用)

- 在结尾加上一对括号，让函数立即被执行

- 将整个函数包裹在一对括号中(只有在你不将函数赋值给一个变量的时候才需要)

```js
(function() {
   // ...
})();
```

**功能**

- 它可以帮你封装大量的工作而不会在背后遗留任何全局变量。

- 你定义的所有变量都会成员立即执行函数的局部变量，所以你不用担心这些临时变量会污染全局空间

- 可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量

- 可以添加更多的加强模块，移除它们，单独测试它们，允许用户去禁用它们等等

一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。

利用**闭包**，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。

```js
(function() {
    // 私有变量
    var age = 20;
    var name = 'Tom';

    // 私有方法
    function getName() {
        return `your name is ` + name;
    }

    // 共有方法
    function getAge() {
        return age;
    }

    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收
    window.getAge = getAge;
})();
```

## 二、函数参数传递方式：按值传递

实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。

```js
var person = {
    name: 'Nicholas',
    age: 20
}

function setName(obj) {  // 传入一个引用
    obj = {};   // 将传入的引用指向另外的值
    obj.name = 'Greg';  // 修改引用的name属性
}

setName(person);
console.log(person.name);  // Nicholas 未被改变
```

## 四、函数式编程

函数式编程的思维则建议我们将这种会多次出现的功能封装起来以备调用。