# 函数

## 一、函数声明、函数表达式、匿名函数与自执行函数

### 函数声明

JavaScript中，有两种声明方式，一个是使用var的变量声明，另一个是使用function的函数声明。

变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，**无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数**。

```js
fn();  // function

function fn() {
    console.log('function');
}
```

### 函数表达式

函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明。我们知道使用var进行变量声明，其实是进行了**两步操作**。

```js
// 变量声明
var a = 20;

// 实际执行顺序
var a = undefined;  // 变量声明，初始值undefined，变量提升，提升顺序次于function声明
a = 20;  // 变量赋值，该操作不会提升
```

当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。

```js
fn(); // 报错
var fn = function() {
    console.log('function');
}
```

```js
在构造函数中添加方法
function Person(name) {
    this.name = name;
    this.age = age;
    // 在构造函数内部中添加方法
    this.getAge = function() {
        return this.age;
    }
    this.
}
// 给原型添加方法
Person.prototype.getName = function() {
    return this.name;
}

// 在对象中添加方法
var a = {
    m: 20,
    getM: function() {
        return this.m;
    }
}
```

### 匿名函数

匿名函数，就是指的没有被显示进行赋值操作的函数。它的使用场景，多**作为一个参数传入另一个函数中**。

由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们也常常称这个匿名函数为**回调函数**。

```js
var a = 10;
var fn = function(bar, num) {
    return bar() + num;
}

fn(function() {
    return a;
}, 20)
```

### 函数自执行与块级作用域

在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。而**函数自执行，其实是匿名函数的一种应用**。

立即执行函数模式是一种语法，可以让你的函数在定义后立即被执行，这种模式本质上就是函数表达式(命名的或者匿名的)，在创建后立即执行；

这种模式有一些几部分组成：

- 使用函数表达式定义一个函数(函数声明不能起作用)

- 在结尾加上一对括号，让函数立即被执行

- 将整个函数包裹在一对括号中(只有在你不将函数赋值给一个变量的时候才需要)

```js
(function() {
   // ...
})();
```

**功能**

- 它可以帮你封装大量的工作而不会在背后遗留任何全局变量。

- 你定义的所有变量都会成员立即执行函数的局部变量，所以你不用担心这些临时变量会污染全局空间

- 可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量

- 可以添加更多的加强模块，移除它们，单独测试它们，允许用户去禁用它们等等

一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。

利用**闭包**，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。

```js
(function() {
    // 私有变量
    var age = 20;
    var name = 'Tom';

    // 私有方法
    function getName() {
        return `your name is ` + name;
    }

    // 共有方法
    function getAge() {
        return age;
    }

    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收
    window.getAge = getAge;
})();
```

## 二、函数参数传递方式：按值传递

实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。

```js
var person = {
    name: 'Nicholas',
    age: 20
}

function setName(obj) {  // 传入一个引用
    obj = {};   // 将传入的引用指向另外的值
    obj.name = 'Greg';  // 修改引用的name属性
}

setName(person);
console.log(person.name);  // Nicholas 未被改变
```
